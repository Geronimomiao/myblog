---
title: 操作系统笔记
time:  2019-11-23
author: wsm
mail: 1030057982@qq.com
github: https://github.com/Geronimomiao/advance
---

## 操作系统演进
****
* 无操作系统
	* 人工操作
	* 用户等待
	* CPU等待人工操作 
	* 资源利用率低
* 批处理系统
	*  无需等待人工操作
	*  批量输入任务
	*  资源利用率提升
	*  多道程序设计
* 分时系统
	* 人-机交互
	* 多用户共享
	* 及时调试程序
	* 资源利用率提升

![enter description here](https://img.wsmpage.cn/learning/2019-11-23/1574493834313.png)


**多道程序设计**
****
* 在计算机内存中同时存放多个程序
* 多道程序在计算机的管理程序下相互穿插运行


## What & Why
****
* 操作系统是管理计算机和软件资源的计算机程序
* 管理配置内存 决定资源供需顺序 控制输入输出设备
* 操作系统提供让用户和系统交互的操作界面

## 基本功能

* 统一管理计算机资源
* 对计算机资源的抽象
* 提供用户与计算机间接口

## 进程

* 是系统进行资源调度和分配的最小单位
* 作为程序运行的载体保障程序运行
* 使操作系统利用率大幅提升

## 进程中的实体

* 标识符( 进程id
	* 唯一标记一个进程 用于区别其他进程
* 状态
	* 标记进程中的进程状态( 运行态  阻塞状态 ...
* 程序计数器
	* 指向下一条即将被执行指令的地址
* 内存指针
	* 程序代码 进程数据 相关指针
* 上下文数据
	* 进程执行时 处理器存储的数据
* IO状态信息
	* 被进程IO操作所占用的文件列表
* 记账信息
	* 使用处理器时间 时钟数总和等         

![enter description here](https://img.wsmpage.cn/learning/2019-11-23/1574493934054.png)

![enter description here](https://img.wsmpage.cn/learning/2019-11-23/1574493958530.png)



## 进程控制块( PCB )

* 用于描述和控制进程运行的通用数据结构
* 记录进程当前状态和控制进程运行的全部信息
* PCB 使得进程是能独立运行的基本单位

## 线程

* 线程是操作系统调度最小单位
* 包含在进程中 是进程实际运行的工作的单位
	* 操作系统对进程的调度 实际上是对进程里线程的调度 
* 一个进程可以并发多个线程 每个线程执行不同任务

![enter description here](https://img.wsmpage.cn/learning/2019-11-23/1574494986803.png)

## 进程状态

* 创建 ( 操作系统提供 fork 函数接口创建进程 
	* 分配PCB
	* 创建进程时拥有 PCB 但其他资源未就绪的状态称为创建状态 
* 就绪 ( 其他资源都准备好 只差 CPU 资源状态 
	* 当进程被分配到出 CPU 以外所有必要资源
	* 只要再获取CPU使用权 就可以立即执行 
	* 当存在多个就绪状态进程 会形成一个队列
		* 就绪队列 
* 阻塞 ( 进程由于某种原因 而放弃 CPU 的状态
	* 如 其他设备未就绪而无法继续执行 
	* 当存在多个阻塞状态进程 会形成一个队列
		* 阻塞队列 
* 执行 ( 进程获取 CPU 其程序正在执行的状态
	* 单核处理器中 只能有一个进程 处于执行状态 
* 终止
	* 系统清理 -> PCB 归还 

![enter description here](https://img.wsmpage.cn/learning/2019-11-28/1574942310125.png)

## 进程间的同步

* 引子
	* 生产者 消费者 问题
	* 哲学家进餐问题

* 进程间的同步
	* 使得并发的多个进程之间可以有效使用资源和相互合作
	* 对竞争资源在多进程间进行使用次序的协调

* 临界资源
	* 临界资源指的一般是作为共享资源却无法同时被多个线程共同访问的共享资源 当有进程在使用临界资源时 其他进程必须依据操作系统系统的同步机制等待占用进程释放该共享资源才可重新竞争使用共享资源

* 原则
	* 空闲让进 资源无占用 允许使用
	* 忙则等待 资源有占用 请求进程等待
	* 有限等待 保证有限等待时间能够使用资源
	* 让权等待 等待时 进程让出 CPU

* 同步方法
	* 消息队列
	* 共享存储
	* 信号量

## 线程同步

* 引子
	* 生产者-消费者问题  哲学家问题
* 同步方法
	* 互斥量
	* 读写锁
	* 自旋锁
	* 条件变量

## 进程类型

* 前台进程
	* 具有终端 可以和用户交互的进程  
* 后台进程
	* 没有占用终端的就是后台进程
	* 后台程序基本不用和用户交互 优先级比前台进程低 
* 守护进程  
	* 特殊的后台进程
	* 很多守护进程在系统引导时启动 一直运行到系统关闭
		* crond
		* sshd
		* httpd
		* mysqld ...


## 进程标记

* 进程ID是 进程唯一标记 每个进程拥有不同ID
* 进程ID表现为一个非负整数 最大值由操作系统限定
![enter description here](https://img.wsmpage.cn/learning/2019-11-29/1574995178674.png)
> ID 为 0 进程  idle 进程 是系统创建第一个进程
> ID 为 1 进程是 init 进程 是 0 号进程的 子进程 完成系统初始化
> init 进程是所有用户进程的祖先进程

![enter description here](https://img.wsmpage.cn/learning/2019-11-29/1574995371519.png)

## 进程调度

* 通过计算机决策 决定哪个就绪进程可以获得CPU使用权
	* 保留旧进程运行信息 请出新进程
	* 选择新进程 准备运行环境CPU
* 调度机制
	* 就绪队列排队机制
	* 选择运行进程委派机制
	* 新老进程上下文切换机制
![enter description here](https://img.wsmpage.cn/learning/2019-11-29/1574997112950.png)

![enter description here](https://img.wsmpage.cn/learning/2019-11-29/1574997090439.png)
* 调度算法
	* 先来先服务调度算法
	* 短进程优先调度算法 
		* 选择就绪队列中 估计运行时间最短的进程 
		* 不利于长作业进程的执行
	* 高优先权优先调度算法
		* 优先选择权重高的进程
		* 使紧迫的任务可以优先处理 
	* 时间片轮转调度算法   
		* 按先来先服务的原则排列就绪进程
		* 每次从队头取出一个待执行进程 分配一个时间片
		* 相对公平的调度算法 但不能保证及时响应用户 

* 调度方式
	* 非抢占式调度
		* 处理器一旦分配给某个进程 就让该进程一直使用下去
		* 调度程序不以任何原因抢占正在被使用的处理器
		* 直到工作完成 或 IO 阻塞才会让出处理器 
	* 抢占式调度 
		* 运行程序以一定策略暂停当前运行的进程
		* 保存好旧进程的上下文信息 分配处理器给新进程 

![enter description here](https://img.wsmpage.cn/learning/2019-11-29/1574997166998.png)

## 前置知识

**死锁**

> 死锁是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。 此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程

* 必要条件
	* 互斥条件
		* 对资源 排他性 ( 某资源只能由一个进程使用 其他进程只能等待 
	* 请求保持条件
		* 进程至少保存一个资源 又提出新的资源请求
		* 新资源被占用 请求被阻塞 
		* 被阻塞进程不释放自己所保存资源
	* 不可剥夺条件
		* 进程获得资源在未完成使用前不能被剥夺
		* 获得资源只能由自身释放
	* 环路等待条件 
		* 发生死锁 必然存在进程-资源 环形链

* 破局 ( 破坏必要条件中 一个或多个
	* 系统规定进程运行前 一次性申请所有需要的资源 
	* 当一个进程请求新的资源得不到满足 必须释放占有的资源
	* 可用资源线性排序 申请必须按照递增申请

* 银行家算法
![enter description here](https://img.wsmpage.cn/learning/2019-11-30/1575119657564.png)  

![enter description here](https://img.wsmpage.cn/learning/2019-11-30/1575119682476.png)

**字块 相对于物理设备的定义**
**页面 相对于逻辑空间的定义**

**页内碎片 ( 内部碎片)**
* 当已经被分配出的内存空间 大于 进程所需要的内存空间 所不能被利用的部分
**页外碎片**
* 未被分配出去 但由于大小而无法分配给申请空间的新进程的内存空闲块

## 存储管理

* 内存分配与回收

![enter description here](https://img.wsmpage.cn/learning/2019-11-30/1575122698583.png)

![enter description here](https://img.wsmpage.cn/learning/2019-11-30/1575123653574.png)

![enter description here](https://img.wsmpage.cn/learning/2019-11-30/1575124180097.png)


**字块 相对于物理设备的定义**
**页面 相对于逻辑空间的定义**
* 页式存储管理 ( 有效提高内存利用率 虽然说存在内存碎片
	* 将进程逻辑空间等分成若干大小的页面
	* 相应的把物理内存空间分成与页面大小的物理块
	* 以页面为单位吧进程空间装进物理内存中分散的物理块 	

![enter description here](https://img.wsmpage.cn/learning/2019-11-30/1575128768895.png)


* 段式存储管理 ( 更好满足用户需求
	* 将进程逻辑空间分成若干大小的页面 ( 非等分
	* 段的长度由连续逻辑长度决定

![enter description here](https://img.wsmpage.cn/learning/2019-11-30/1575128731293.png)


* 段页式存储管理
	* 先将逻辑空间按段式管理分成若干段
	* 再把段内空间按页式管理分成若干页

![enter description here](https://img.wsmpage.cn/learning/2019-11-30/1575128704580.png)

![enter description here](https://img.wsmpage.cn/learning/2019-11-30/1575128678141.png)	  

**虚拟内存**
* 由来
	* 有些进程实际需要的内存很大 远超物理内存容量
	* 多道程序设计 使得每个内存可用的物理内存更加稀缺
	* 不可能无限增加物理内存 物理内存总有不够的时候

* 概述
	* 把程序使用内存划分 将暂时不用的内存放置在辅存 ( 硬盘
	
* 程序局部性原理
	* CPU 访问存储器时 无论是存取指令还是存取数据 所访问的存储单元都趋于聚集在一个较小时连续区域中
	* 程序运行时 无需全部装入内存 装载部分即可
	* 如果访问页不在内存 则发出缺页中断 发起页面置换
	* 从用户层面看 程序拥有很大的空间  	
	
* 虚拟内存置换算法
	* 先进先出算法 ( FIFO
	* 最不经常使用算法 ( LFU
	* 最近最少使用算法 ( LRU

> 替换策略发生在 Cache-主存   主存-辅存
> 前者解决速度问题 后者解决容量问题



**Linux 存储管理**
* Buddy 内存管理算法 ( 努力让内存分配与相邻内存合并快速进行
	* 基于计算机处理二进制的优势具有极高的效率
	* 算法主要是为了解决内存外碎片问题 ( 内存外碎片 -> 内存内碎片 
	* 核心
		* 将申请内存大小向上取 2的幂  
		* 一片连续内存的 '伙伴(buddy)' 是相邻的另一片大小一样的连续内存

![enter description here](https://img.wsmpage.cn/learning/2019-12-1/1575158967760.png)

![enter description here](https://img.wsmpage.cn/learning/2019-12-1/1575159010252.png)
![enter description here](https://img.wsmpage.cn/learning/2019-12-1/1575159029882.png)

![enter description here](https://img.wsmpage.cn/learning/2019-12-1/1575159053064.png)


## 操作系统设备管理

* 广义的 IO 设备
	* 对 CPU  而言 凡是对 CPU 进行设备输入对都是输入设备
	* 对 CPU  而言 凡是对 CPU 进行设备输出对都是输出设备

* IO 设备缓冲区
	* 减少 CPU 处理 IO 请求对频率
	* 提高 CPU 与 IO 设备之间的并行性

* IO 设备的分类
![enter description here](https://img.wsmpage.cn/learning/2019-12-1/1575192766056.png)  

![enter description here](https://img.wsmpage.cn/learning/2019-12-1/1575192785141.png)

![enter description here](https://img.wsmpage.cn/learning/2019-12-1/1575192799191.png)

![enter description here](https://img.wsmpage.cn/learning/2019-12-1/1575192820753.png)


**IO设备缓冲区**

![enter description here](https://img.wsmpage.cn/learning/2019-12-1/1575192840947.png)

* 专用缓冲区只适用于特定进程 ( 当这样 IO 进程比较多 对内存消耗也很大
* 操作系统划出可供多个进程使用的公共缓冲区 ( 称之为缓冲池

![enter description here](https://img.wsmpage.cn/learning/2019-12-1/1575193784135.png)


**SPOOLing 技术**
* 关于慢速字符设备如何与计算机主机交换信息的一种技术
* 利用高速共享设备将低速的独享设备模拟成高速的共享设备
* 逻辑上 系统为每个用户都分配了一台独立高速共享设备

![enter description here](https://img.wsmpage.cn/learning/2019-12-1/1575193802893.png)
![enter description here](https://img.wsmpage.cn/learning/2019-12-1/1575193824610.png)
