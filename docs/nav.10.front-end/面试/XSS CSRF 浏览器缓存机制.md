---
title: XSS CSRF 浏览器缓存机制
---

#### CSRF
 ****
 >  跨站请求伪造
 >  跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的

 ```
 假如一家银行用以运行转账操作的URL地址如下： http://www.examplebank.com/withdraw?account=AccoutName&amount=1000&for=PayeeName

那么，一个恶意攻击者可以在另一个网站上放置如下代码： <img src="http://www.examplebank.com/withdraw?account=Alice&amount=1000&for=Badman">

如果有账户名为Alice的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失1000资金。

这种恶意的网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。这意味着如果服务端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。

透过例子能够看出，攻击者并不能通过CSRF攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户的浏览器，让其以用户的名义运行操作
 ```


#### XSS
****
>  跨站脚本
>   攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。


#### 浏览器缓存机制
****
>  浏览器的缓存机制也就是我们说的HTTP缓存机制，其机制是根据HTTP报文的缓存标识进行的

* 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识
* 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中
> 根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强制缓存和协商缓存

**强缓存**
* 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）
* 存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存(暂不分析)
* 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果

**协商缓存**
> 协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程
* 协商缓存生效，返回304 ( 服务端资源未更新
* 协商缓存失效，返回200和请求结果结果  (服务端资源更新


**浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效**
* from memory cache 
* from disk cache 

>  from memory cache代表使用内存中的缓存，from disk cache则代表使用的是硬盘中的缓存
* 内存缓存(from memory cache)
  * 内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取
  * 时效性：一旦该进程关闭，则该进程的内存则会清空
* 硬盘缓存(from disk cache)
  * 硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢  

>  在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)

**强缓存控制字段**
>  控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高
* Expires
  * 其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果 
* Cache-Control
  * public：所有内容都将被缓存（客户端和代理服务器都可缓存）
  * private：所有内容只有客户端可以缓存，Cache-Control的默认取值
  * no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定
  * no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
  * max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效

**协商缓存控制字段**
>  Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高
* Last-Modified / If-Modified-Since
  * Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间
  * If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件 
* Etag / If-None-Match
  * Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)
  * If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200

****
>  强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存

* 感悟 
  * 浏览器发起请求前 会先判断浏览器是否存在对应的缓存 
  * 强缓存 在浏览器进行校验( 若失效 则使用协商缓存
  * 协商缓存 在服务端进行校验


![附图](https://user-gold-cdn.xitu.io/2018/4/19/162db635ed5f6d26?imageslim)