---
title: 语法笔记
---

## 异步操作

如果多个异步操作 不相互依赖 可以让他们同时触发 而不是相继触发
```js
// 相继触发
let foo = await getFoo()
let bar = await getBar()

// 同时触发
let [foo, bar] = await Promise.all([getFoo(), getBar()])

let fooPromise = getFoo()
let barPromise = getBar()
let foo = await fooPromise
let bar = await barPromise
```

## 类

constructor 是类的默认方法 通过 new 调用对象实例会默认调用该方法 如果没有显示定义 一个空的 
constructor 方法也会默认添加 默认返回对象实例 this

类方法均定义在 prototype 对象上 
类属性除非显示定义在其本身( this )  否则都是定义在原型上
```js
constructor() {}
```

继承
```js
// 子类必须在 constructor 函数 中调用 super 方法 否则新建实例就会报错
// 子类没有自己的 this 对象 而是继承父类的 this 然后对其加工
// 如果不调用 super 方法 子类就得不到 this 对象
class ColorPoint extends Point {
	constructor(x, y, color) {
		super(x, y)
		this.color = color
	}
	
	toString() {
		return this.color + '' + super.toString()
	}
}
```

```js
// 若子类没有 constructor 这个方法会默认添加
constructor(...args){
	super(...args)
}
```

静态方法
在方法前加一个 static 关键字 表示该方法不会被实例继承 
而是直接通过类来调用

静态属性(ES6 不支持
指class本身的属性 而不是定义在实例对象(this)上的属性
```js
// ES6 写法
class Foo{}
Foo.prop = 1

// ES7 对实例属性 类属性 规定了新的写法
// 实例属性可以用等式写入类的定义 以前必须在 constructor 中定义
// 类的静态属性 加上 static 关键字即可
class Myclass {
	myProp = 42;
	static prop =1;
	constructor() {
		console.log(this.myProp)
	}
}
```



## ES6 模块导入导出
```js
//foo.js
'use strict'


//export与export default都可以导出常量、函数、文件、模块等。
//在文件或模块中,export default有且仅有一个,export可以有多个。
//export可以直接导出变量表达式,export default不行。
//通过export方式导出时,导入需要加{},export default则不用。


//导出变量
export const a = 'ES6的export导出常量'
const b = 24;
export default b; //不能写 export defult const b = 24;

//导出function
export const func1 = function(){
    console.log('ES6的export导出function1')
}
export const func2 = function(){
    console.log('ES6的export导出function2')
}
export {func1,func2}


//test.js
'use strict'
const express = require('express');
const router = express.Router();

import {func1, func2} from './foo.js'; //导入export导出的两个function
import b from './foo.js'; //导入 export default导出的常量b
import * as testModule from './foo.js'; //as是作为集合成对象导入


/*GET HOME PAGE */
router.get('/',function(req,res,next){
    func1(); //ES6的export导出function1
    func2(); //ES6的export导出function2
    console.log(b); // 24
    testModule.func1(); //ES6的export导出function1
    testModule.func2(); //ES6的export导出function2
    console.log(testModule.b); //undefined,因为as导出是把零散的export合成一个对象而export default是导出为default属性
    console.log(testModule.default); // 24
}
module.exports = router;

```

common.js 模块导入导出
```js
/*  CommonJS定义模块分为：模块标识(module)、模块定义(exports)、模块引用(require)
其实是这样的每一个node.js执行文件，都会自动创建一个exports和module对象，同时module对象会创建一个叫exports的属性，初始化的值是 {}
exports = module.exports = {}
exports和module.exports都会指向一个{}内存区域
*/

//foo.js
let a = 24;

console.log(module.exports); //打印结果为 {}
console.log(exports); //打印结果为 {}

exports.a = 2400; // exports改变module.exports里面的内容为{a: 2400}

console.log(module.exports); //打印结果为 {a: 2400}
console.log(exports); //打印结果为 {a: 2400}

exports = '指向其他内存区域不再指向a'; //改变exports指向的内存区域

//test.js
let a = require('./foo');
console.log(a); //打印结果为 {a: 2400}
/*
由此结果可以很清晰的看出，require导入进来的内容是module.exports导出的所指向内存a的内容并不是exports的。说白了exports就是领导(module.exports)的秘书只负责起草稿子，出去念稿子的还是领导(module.exports)。
*/
```

****
* CommonJS 输出是一个值的拷贝
* ES6 输出为值引用 遇到加载模块命令 import 不会去执行模块 而是生成一个动态引用 等到需要时 去模块里取值 如果模块中原始值改变 取到的值也会变
* 由于 ES6 输入模块变量 只是一个 符号链接 所以变量为只读 对它进行重新赋值会报错



## Mixin 模式实现

将多个类接口 混入另一个类

```js
function mix(...mixins) {
	class Mix{}
	
	for(let mixin of mixins){
		copyProperties(Mix, mixin);
		copyProperties(Mix.prototype, mixin.prototype);
	}
	
	return Mix;
}

function copyProperties(target, source) {
	for(let key of Reflect.ownKeys(source)) {
		if(key !== 'constructor' && key !== 'prototype' && key !== 'name') {
			let desc = Object.getOwnPropertyDescriptor(source, key)
			Object.defineProperty(target, key, desc)
		}
	}
}

// 使用
class DistributeEdit extends mix(Loggable, Serializable) {

}
```

## 修饰器

修饰器对类对行为改变 是代码编译时发生的 而不是运行时 这意味着修饰器能在编译阶段运行代码
```js
// 类修饰器
function testable(target) {
	target.isTestable = true;
}

@testable
class MyTestableClass {}
 
console.log(MyTestableClass.isTestable) // true

@decorator
class A {}

// 等价于
class A {}
A = decorator(A) || A

// 若参数不够用 可以在封装一层函数
function testable(isTestable) {
	return function(target) {
		target.isTestable = isTestable
	}
}

@testable(true)
class MyTestableClass {}

// 修饰器不仅可以修饰类 还可以修饰类的属性
class Person {
	@readonly
	name() { return `${this.first}${this.last}` }
}

// 此时 修饰器函数一共可以接受三个参数 
// 所要修饰的目标对象 所要修饰的属性名 属性描述的对象
function readonly(target, name, descriptor) {
	descriptor.writable = false;
	return descriptor;
}

// 类似于
Object.defineProperty(Person.prototype, 'name', descriptor);

// 修饰器只能修饰类和类方法 不能用于函数 因为存在函数提升
```


## rest 参数 和 扩展运算符

> rest参数用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中
> 扩展运算符可以看做是 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列




## 编程风格

* let 取代 var
* let const 之间 优先使用 const 尤其在全局环境下
* 静态字符串 一律使用 单引号 或 反引号 动态字符串使用反引号
* 解构赋值
	* 数组成员对变量赋值
	* 函数参数是对象成员 

```js
const arr = [1, 3, 4]
const [a, b] = arr

function getFullName({ firstName, lastName }) {
}

// 函数返回多个值 优先使用对象解构 而不是数组解构
// 便于添加 返回值 以及 更改返回值的顺序
function processInput(input) {
	return { letf, right, top, bottom };
}

const { left, right } = processInput(input);
```

* 单行对象 不以最后一个成员 不以逗号结尾 
* 多行对象 最后一个成员 以逗号结尾 

```js
const a = {x: null}
a.x = 3


var ref = 'some value';

const atom = {
	ref,
	value: 1,
	addValue(value) {
		return atom.value + value;
	}
}
```

* 使用扩展运算符(...)拷贝数组
* 使用 Array.from 方法 将类数组对象 转为 对象

```js
const itemCopy = [...items]

const foo = doncument.querySelectorAll('.foo')
const nodes = Array.from(foo)
```

* 不要在函数体内使用 arguments  变量 用 rest 运算符代替
* rest 运算符可以显示的表达你想要获取的参数 而 arguments 是一个类数组对象 rest 参数 可以提供一个真正的数组
* 使用默认值语法为函数参数设置默认值